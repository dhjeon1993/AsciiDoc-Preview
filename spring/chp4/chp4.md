# 예외

자바 개발자가 가장 신경 쓰기 귀찮아하는 것 중의 하나가 바로 예외처리이다.
정상적인 결과와 흐름을 보여주는 코드를 만들기도 버거운데 예외상황까지 처리해야 한다는 사실이 부담스러울 수도 있다.
그래서 예외와 관련된 코드는 자주 엉망이 되거나 무성의하게 만들어지기 쉽다.
때론 잘못된 예외처리 코드 때문에 찾기 힘든 버그를 낳을 수도 있고, 생각지 않았던 예외상황이 발생했을 때 상상 이상으로 난처해질 수도 있다.

## 예외처리 시 주의할 사항

### 예외 블랙홀

```java
try {
    ...
} catch(Exception e) {
}
```
예외를 잡고는 아무것도 하지 않는다.
예외 발생을 무시해버리고 정상적인 상황인 것처럼 다음 라인으로 넘어가겠다는 분명한 의도가 있는 게 아니라면 연습 중에도 **절대 만들어서는 안되는 코드**다.

-> 처음 예외 처리용 코드를 만들면서 생긴 잘못된 습관이 계속 남아 있는 게 문제의 원인이다.

### 예외가 발생했을 때 아무것도 하지 않고 넘어가서는 안되는 이유

프로그램 실행 중에 어디선가 오류가 있어서 예외가 발생했는데 그것을 무시하고 계속 진행해버리기 때문이다.
결국 발생한 예외로 인해 어떤 기능이 비정상적으로 동작하거나, 메모리나 리소스가 소진되거나, 예상치 못한 다른 문제를 일으킬 것이다.
최종적으로 오작동을 하거나 시스템 오류가 나서 운영자가 알아차렸을 때는 이미 조치를 취하기엔 너무 늦었다.
더 큰 문제는 그 시스템 오류나 이상한 결과의 **원인이 무엇인지 찾아내기가 매우 힘들다는 점**이다.

```java
} catch (Exception e) {
    System.out.println(e);
}
```
```java
} catch (Exception e) {
    e.printStackTrace();
}
```

개발 중에는 IDE 콘솔이나 서버 실행창에 이 메시지가 눈에 확 띄게 보이니 문제가 생겨도 금방 알아차리고 뭔가 조치를 취할 수 있을지 모르겠다.
하지만 운영서버에 올라가면 더욱 심각하다. 콘솔 로그를 누군가가 계속 모니터링하지 않는 한 이 예외 코드는 심각한 폭탄으로 남아 있을 것이다. 
**예외는 처리돼야 한다.**

### 예외를 처리할 때 반드시 지켜야 할 핵심 원칙

모든 예외는 적절하게 복구되든지 아니면 작업을 중단시키고 운영자 또는 개발자에게 분명하게 통보돼야 한다.

**굳이 예외를 잡아서 뭔가 조치를 취할 방법이 없다면 잡지 말아야 한다.**

### 무의미하고 무책임한 throws

자신이 사용하려고 하는 메소드에 `throws Exception`이 선언되어 있다고 생각해보자. 그런 메소드 선언에서는 **의미 있는 정보를 얻을 수 없다.** 결국 이런 메소드를 사용하는 메소드에서도 역시 `throws Exception`을 따라서 붙이는 수밖에 없다. 결과적으로 적절한 처리를 통해 **복구될 수 있는 예외상황도 제대로 다룰 수 있는 기회를 박탈**당한다.

---

## 예외의 종류와 특징

자바에서는 `throw`를 통해 발생시킬 수 있는 예외는 크게 세 가지가 있다.

*   Error

    `java.lang.Error` 클래스의 서브클래스들이다. 에러는 **시스템에 뭔가 비정상적인 상황이 발생했을 경우에 사용**된다. 그래서 **주로 자바 VM에서 발생시키는 것**이고 **애플리케이션 코드에서 잡으려고 하면 안 된다**.

    따라서 시스템 레벨에서 특별한 작업을 하는게 아니라면 애플리케이션에서는 이런 에러에 대한 처리는 신경 쓰지 않아도 된다.

*   Exception과 체크 예외

    `java.lang.Exception` 클래스와 그 서브클래스로 정의되는 예외들을 에러와 달리 개발자들이 만든 애플리케이션 코드의 작업 중에 예외상황이 발생했을 경우에 사용된다.

    `Exception` 클래스는 다시 체크 예외(checked exception)와 언체크 예외(unchecked exception)로 구분된다.

    *   체크 예외(checked exception)
    
        체크 예외는 `Exception` 클래스의 서브클래스이면서 `RuntimeException` 클래스를 상속하지 않은 것이다.

        일반적으로 예외라고 하면 `Exception` 클래스의 서브클래스 중에서 `RuntimeExcception`을 상속하지 않은 것만을 말하는 체크 예외라고 생각해도 된다. **체크 예외가 발생할 수 있는 메소드를 사용할 경우 반드시 예외를 처리하는 코드를 함께 작성해야 한다.**
    
    *   언체크 예외(unchecked exception)

        언체크 예외는 `RuntimeException`을 상속한 클래스들을 말한다.

*   RuntimeException과 언체크/런타임 예외

    `java.lang.RuntimeException` 클래스를 상속한 예외들은 명시적인 예외처리를 강제하지 않기 때문에 언체크 예외라고 불린다. 또는 대표 클래스 이름을 따서 런타임 예외라고도 한다. 에러와 마찬가지로 이 런타임 예외는 `catch` 문으로 잡거나 `throws`로 선언하지 않아도 된다. 물론 명시적으로 잡거나 `throws`로 선언해줘도 상관없다.

    런타임 예외는 주로 **프로그램의 오류가 있을 때 발생하도록 의도된 것들**이다.

---

## 예외처리 방법

### 예외 복구

예외 복구는 예외상황을 파악하고 문제를 해결해서 **정상 상태로 돌려놓는 것**이다.

예외가 처리되었으면 비록 기능적으로는 사용자에게 예외상황으로 비쳐도 애플리케이션에서는 정상적으로 설계된 흐름을 따라 진행돼야 한다.

### 예외처리 회피

예외처리를 자신이 담당하지 않고 **자신을 호출한 쪽으로 던져버리는 것**이다. `throws` 문으로 선언해서 예외가 발생하면 알아서 던져지게 하거나 `catch` 문으로 일단 예외를 잡은 후에 로그를 남기고 다시 예외를 던지는(rethrow) 것이다.

빈 `catch` 블록으로 잡아서 예외가 발생하지 않은 것처럼 만드는 경우는 회피한 것은 아니다. 예외처리를 회피하려면 반드시 다른 오브젝트나 메소드가 **예외를 대신 처리할 수 있도록 예외를 던져줘야 한다**.

콜백 오브젝트의 메소드는 예외를 회피하고 템플릿 레벨에서 처리하도록 던져준다.

하지만 콜백과 템플릿처럼 긴밀하게 역할을 분담하고 있는 관계가 아니라면 자신의 코드에서 발생하는 **예외를 그냥 던져버리는 건 무책임한 책임회피**일 수 있다.

예외를 회피하는 것은 예외를 복구하는 것처럼 **의도가 분명해야 한다**. 

### 예외 전환(exception translation)

예외 회피와 비슷하게 예외를 복구해서 정상적인 상태로는 만들 수 없기 때문에 예외를 메소드 밖으로 던지는 것이다. 하지만 예외 회피와 달리, 발생한 예외를 그대로 넘기는 게 아니라 **적절한 예외로 전환해서 던진다**는 특징이 있다.

전환하는 예외에 원래 발생한 예외를 담아서 **중첩 예외(nested exception)로 만드는 것이 좋다**. 중첩 예외는 `getCause()` 메소드를 이용해서 처음 발생한 예외가 무엇인지 확인할 수 있다.

#### 예외 전환의 두가지 목적

*   내부에서 발생한 예외를 그대로 던지는 것이 그 예외상황에 대한 적절한 의미를 부여해주지 못하는 경우에, 의미를 분명하게 
해줄 수 있는 예외로 바꿔주기 위함이다.

*   예외를 처리하기 쉽고 단순하게 만들기 위해 포장(wrap)하는 것이다. 중첩 예외를 이용해 새로운 예외를 만들고 원인이 되는 예외를 내부에 담아서 던지는 방식은 같다. 하지만 의미를 명확하게 하려고 다른 예외로 전환하는 것이 아니다. 주로 예외처리를 강제하는 체크 예외를 언체크 예외인 런타임 예외로 바꾸는 경우에 사용한다.

일반적으로 체크 예외를 계속 `throws`를 사용해 넘기는 건 무의미하다. 메소드 선언은 지저분해지고 아무런 장점이 없다.

대부분 서버환경에서는 애플리케이션 코드에서 처리하지 않고 전달된 예외들을 일괄적으로 다룰 수 있는 기능을 제공한다. 어차피 복구하지 못할 예외라면 애플리케이션 코드에서는 런타임 예외로 포장해서 던져버리고, 예외처리 서비스 등을 이용해 자세한 로그를 남기고, 관리자에게는 메일 등으로 통보해주고, 사용자에게는 친절한 안내 메시지를 보여주는 식으로 처리하는 게 바람직하다.

---

## 예외처리 전략

### 런타임 예외의 보편화

자바의 환경이 서버로 이동하면서 체크 예외의 활용도와 가치는 점점 떨어지고 있다. 자칫하면 `throws Exception`으로 점철된 아무런 의미도 없는 메소드들을 낳을 뿐이다. 그래서 **대응이 불가능한 체크 예외라면 빨리 런타임 예외로 전환**해서 던지는 게 낫다.

예전에는 복구할 가능성이 조금이라도 있다면 체크 예외로 만든다고 생각했는데, 지금은 항상 복구할 수 있는 예외가 아니라면 일단 언체크 예외로 만드는 경향이 있다. 언체크 예외라도 필요하다면 얼마든지 `catch` 블록으로 잡아서 복구하거나 처리할 수 있다.

런타임 예외 중심의 전략은 굳이 이름을 붙이자면 **낙관적인 예외처리 기법**이라고 할 수 있다. 일단 복구할 수 있는 예외는 없다고 가정하고 예외가 생겨도 어차피 런타임 예외이므로 시스템 레벨에서 알아서 처리해줄 것이고, 꼭 필요한 경우는 런타임 예외라도 잡아서 복구하거나 대응해줄 수 있으니 문제 될 것이 없다는 낙관적인 태도를 기반으로 하고 있다. 

### 애플리케이션 예외

런타임 예외와 달리, 직접 처리할 수 없는 예외가 대부분이라고 하더라도 혹시 놓치는 예외가 있을 수 있으니, 일단 잡고 보도록 강제하는 체크 예외의 **비관적인 접근 방법**이다.

시스템 또는 외부의 예외상황이 원인이 아니라 애플리케이션 자체의 로직에 의해 의도적으로 발생시키고, 반드시 `catch` 해서 무엇인가 조치를 취하도록 요구하는 예외를 애플리케이션 예외라고 한다.

#### 리턴 값을 통한 예외처리의 단점

*   리턴 값을 명확하게 코드화하고 잘 관리하지 않으면 혼란이 생길 수 있다.
*   정상적인 처리가 안 됐을 때 전달하는 값의 표준 같은 것은 없다.
*   결과 값을 확인하는 조건문이 자주 등장한다.

---

## 스프링의 예외처리 전략과 원칙

### `SQLException`은 복구 가능한 예외인가?

99%의 `SQLException`은 코드 레벨에서는 복구할 방법이 없다. 프로그램의 오류 또는 개발자의 부주의 때문에 발생하는 경우이거나, 통제할 수 없는 외부상황 때문에 발생하는 것이다.

대부분의 `SQLException`은 복구가 불가능하다. 더군다나 DAO 밖에서 `SQLException`을 다룰 수 있는 가능성은 거의 없다. 따라서 예외처리 전략을 적용해야 한다. 필요도 없는 기계적인 `thorws` 선언이 등장하도록 방치하지 말고 가능한 한 빨리 언체크/런타임 예외로 전환해줘야 한다.

### 스프링의 예외처리

스프링의 `JdbcTemplate`은 바로 이 예외처리 전략을 따르고 있다. `JdbcTemplate` 템플릿과 콜백 안에서 발생하는 모든 `SQLException`을 런타임 예외인 `DataAccessException`으로 포장해서 던져준다.

그 밖에도 스프링의 API 메소드에 정의되어 있는 대부분의 예외는 **런타임 예외**이다. 따라서 발생 가능한 예외가 있다고 하더라도 이를 처리하도록 강제하지 않는다.

---

## JDBC의 한계

JDBC는 자바 표준 JDK에서도 가장 많이 사용되는 기능 중의 하나다. JDBC는 자바를 이용해 DB에 접근하는 방법을 추상화된 API 형태로 정의해놓고, 각 DB 업체가 JDBC 표준을 따라 만들어진 드라이버를 제공하게 해준다. 내부 구현은 DB 마다 다르겠지만 JDBC의 `Connection`, `Statement`, `ResultSet` 등의 표준 인터페이스를 통해 그 기능을 제공해주기 때문에 자바 개발자들은 표준화된 JDBC의 API에만 익숙해지면 DB의 종류에 상관없이 일관된 방법으로 프로그램을 개발할 수 있다. 인터페이스를 사용하는 객체지향 프로그래밍 방법의 장점을 잘 경험할 수 있는 것이 바로 이 JDBC다.

하지만 DB 종류에 상관없이 사용할 수 있는 데이터 액세스 코드를 작성하는 일은 쉽지 않다. 표준화된 JDBC API가 DB 프로그램 개발 방법을 학습하는 부담은 확실히 줄여주지만 DB를 자유롭게 변경해서 사용할 수 있는 유연한 코드를 보장해주지는 못한다. 현실적으로 DB를 자유롭게 바꾸어 사용할 수 있는 DB 프로그램을 작성하는 데는 두 가지 걸림돌이 있다.

### DB를 자유롭게 바꾸기 힘든 점들

*   비표준 SQL
    
    SQL은 어느 정도 표준화된 언어이고 몇 가지 표준 규약이 있긴 하지만, 대부분의 DB는 표준을 따르지 않는 비표준 문법과 기능도 제공한다. 이런 비표준 특정 DB 전용 문법은 매우 폭넓게 사용되고 있다. 해당 DB의 특별한 기능을 사용하거나 최적화된 SQL을 만들 때 유용하기 때문이다.

    대용량 데이터를 처리하는 경우 성능을 향상시키기 위해 최적화 기법을 SQL에 적용하거나, 웹 화면의 페이지 처리를 위해 가져오는 로우의 시작 위치와 개수를 지정하거나, 쿼리에 조건을 포함시킨다거나, 특별한 기능을 제공하는 함수를 SQL에 사용하려면 대부분 비표준 SQL 문장이 만들어진다. 이렇게 작성된 비표준 SQL은 결국 DAO 코드에 들어가고, 해당 DAO는 특정 DB에 대해 종속적인 코드가 되고 만다. 다른 DB로 변경하려면 DAO에 담긴 SQL을 적지 않게 수정해야 한다. 보통은 DB가 자주 변경되지도 않고, 사용하는 DB에 최적화되는 것이 중요하므로 비표준 SQL을 거리낌없이 사용한다. 하지만 DB의 변경 가능성을 고려해서 유연하게 만들어야 한다면 SQL은 제법 큰 걸림돌이 된다.

    이 문제의 해결책을 생각해보면, 호환 가능한 표준 SQL만 사용하는 방법과, DB별로 별도의 DAO를 만들거나 SQL을 외부에 독립시켜서 DB에 따라 변경해 사용하는 방법이 있다. 표준 SQL만을 사용할 경우, 당장에 웹 프로그램에서 자주 필요로 하는 페이징 쿼리에서부터 문제가 된다. 따라서 표준 SQL만 사용하는 방법은 간단한 예제 프로그램이라면 모를까 그다지 현실성이 없다. 결국 사용할 수 있는 방법은 DAO를 DB별로 만들어 사용하거나 SQL을 외부에서 독립시켜서 바꿔 쓸 수 있게 하는 것이다.

*   호환성 없는 `SQLException`의 DB 에러정보

    DB를 사용하다가 발생할 수 있는 예외의 원인은 다양하다. 문제는 DB마다 SQL만 다른 것이 아니라 에러의 종류와 원인도 제각각이라는 점이다. 그래서 JDBC는 데이터 처리 중에 발생하는 다양한 예외를 그냥 `SQLException` 하나에 모두 담아버린다. JDBC API는 이 `SQLException` 한 가지만 던지도록 설계되어 있다. 예외가 발생한 원인은 `SQLException` 안에 담긴 에러 코드와 SQL 상태정보를 참조해 봐야 한다. 그런데 `SQLException`의 `getErrorCode()`로 가져올 수 있는 DB 에러 코드는 DB별로 모두 다르다. DB 벤더가 정의한 고유한 에러 코드를 사용하기 때문이다.

    그래서 예외가 발생했을 때의 DB 상태를 담은 SQL 상태정보를 부가적으로 제공한다. `getSQLState()` 메소드로 예외상황에 대한 상태정보를 가져올 수 있다. 이 상태정보는 DB별로 달라지는 에러 코드를 대신할 수 있도록, *Open Group*의 **XOPEN SQL** 스펙에 정의된 SQL 상태 코드를 따르도록 되어 있다.

    `SQLException`이 이러한 상태 코드를 제공하는 이유는 DB에 독립적인 에러정보를 얻기 위해서다. 그런데 문제는 DB의 JDBC 드라이버에서 `SQLException`을 담을 상태 코드를 정확하게 만들어주지 않는다는 점이다. 결과적으로 이 SQL 상태 코드를 믿고 결과를 파악하도록 코드를 작성하는 것은 위험하다.

    결국 호환성 없는 에러 코드와 표준을 잘 따르지 않는 상태 코드를 가진 `SQLException` 만으로 DB에 독립적인 유연한 코드를 작성하는 것은 불가능에 가깝다.

---

##  DB 에러 코드 매핑을 통한 전환

`SQLException`에 담긴 SQL 상태 코드는 신뢰할 만한 게 아니므로 더 이상 고려하지 않는다. 차라리 DB 업체별로 만들어 유지해오고 있는 DB 전용 에러 코드가 더 정확한 정보라고 볼 수 있다. SQL 상태 코드는 JDBC 드라이버를 만들 때 들어가는 것이므로 같은 DB라고 하더라도 드라이버를 만들 때마다 달라지기도 하지만, DB 에러 코드는 DB에서 직접 제공해주는 것이니 버전이 올라가더라도 어느 정도 일관성이 유지된다.

해결 방법은 DB별 에러 코드를 참고해서 발생한 예외의 원인이 무엇인지 해석해 주는 기능을 만드는 것이다. DB 종류에 상관없이 동일한 상황에서 일관된 예외를 전달받을 수 있다면 효과적인 대응이 가능하다.

스프링은 `DataAccessException`이라는 `SQLException`을 대체할 수 있는 런타임 예외를 정의하고 있을 뿐 아니라 `DataAccessException`의 서브클래스로 세분화된 예외 클래스들을 정의하고 있다. 스프링은 DB별 에러 코드를 분류해서 스프링이 정의한 예외 클래스와 매핑해놓은 에러 코드 매핑정보 테이블을 만들어두고 이를 이용한다.

### 오라클 에러 코드와 매핑 파일
```XML
<bean id="Oracle" class="org.springframework.jdbc.support.SQLErrorCodes">
    <property name="badSqlGrammarCodes">
        <value>900,903,904,917,936,942,17006</value>
    </property>
    <property name="invalidResultSetAccessCodes">
        <value>17003</value>
    </property>
    <property name="duplicateKeyCodes">
        <value>1</value>
    </property>
    <property name="dataIntegrityViolationCodes">
        <value>1400,1722,2291,2292</value>
    </property>
    <property name="dataAccessResourceFailureCodes">
        <value>17002,17447</value>
    </property>
    ...
</bean>
```

`JdbcTemplate`을 이용한다면 JDBC에서 발생하는 DB 관련 예외는 거의 신경쓰지 않아도 된다.

---

## DAO 인터페이스와 DataAccessException 계층구조

`DataAccessException`은 의미가 같은 예외라면 데이터 액세스 기술의 종류와 강관없이 일관된 예외가 발생하도록 만들어준다. 데이터 액세스 기술에 독립적인 추상화된 예외를 제공하는 것이다.

### DAO 인터페이스와 구현의 분리

#### DAO를 따로 만들어서 사용하는 이유

*   데이터 액세스 로직을 담은 코드를 성격이 다른 코드에서 분리해놓기 위해서다.
*   DAO는 인터페이스를 사용해 구체적인 클래스 정보와 구현 방법을 감추고, DI를 통해 제공되도록 만든다.

DAO의 사용 기술과 구현 코드는 전략 패턴과 DI를 통해서 DAO를 사용하는 클라이언트에게 감출 수 있지만, 메소드 선언에 나타나는 예외정보가 문제가 될 수 있다.

```java
public void add(User user) throws SQLException;
```
이렇게 정의한 인터페이스는 JDBC가 아닌 데이터 액세스 기술로 DAO 구현을 전환하면 사용할 수 없다. 데이터 액세스 기술의 API는 자신만의 독자적인 예외를 던지기 때문에 `SQLException`을 던지도록 선언한 인터페이스 메소드는 사용할 수 없다.

대부분의 데이터 엑세스 예외는 애플리케이션에서는 복구 불가능하거나 할 필요가 없는 것이다. 그렇다고 모든 예외를 다 무시해야 하는 건 아니다. 애플리케이션에서는 사용하지 않더라도 시스템 레벨에서 데이터 액세스 예외를 의미 있게 분류할 필요도 있다. 문제는 데이터 액세스 기술이 달라지면 같은 상황에서도 다른 종류의 예외가 던져진다는 점이다. 따라서 DAO를 사용하는 클라이언트 입장에서는 DAO의 사용 기술에 따라서 예외 처리 방법이 달라져야 한다. 결국 클라이언트가 DAO의 기술에 의존적이 될 수밖에 없다.

### 데이터 액세스 예외 추상화와 DataAccessException 계층구조

스프링은 자바의 다양한 데이터 액세스 기술을 사용할 때 발생하는 예외들을 추상화해서 `DataAccessException` 계층구조 안에 정리해놓았다.

`DataAccessException`은 자바의 주요 데이터 액세스 기술에서 발생할 수 있는 대부분의 예외를 추상화하고 있다. 데이터 액세스 기술에 상관없이 공통적인 예외도 있지만 일부 기술에서만 발생하는 예외도 있다. 스프링의 `DataAccessException`은 이런 일부 기술에서만 공통적으로 나타나는 예외를 포함해서 데이터 액세스 기술에서 발생 가능한 대부분의 예외를 계층구조로 분류해놓았다.

`JdbcTemplate`과 같이 스프링의 데이터 액세스 지원 기술을 이용해 DAO를 만들면 사용 기술에 독립적인 일관성 있는 예외를 던질 수 있다. 결국 인터페이스 사용, 런타임 예외 전환과 함께 `DataAccessException` 예외 추상화를 적용하면 데이터 액세스 기술과 구현 방법에 독립적인 이상적인 DAO를 만들 수가 있다.

##  DataAccessException 활용 시 주의사항

`DuplicateKeyException`은 아직까지는 JDBC를 이용하는 경우에만 발생한다. 데이터 액세스 기술을 *하이버네이트*나 *JPA*를 사용했을 때도 동일한 예외가 발생할 것으로 기대하지만 실제로 다른 예외가 던져진다. 그 이유는 JDBC의 경우와 달리 다른 기술들은 세분화되어 있지 않기 때문이다.

`DataAccessException`이 기술에 상관없이 어느 정도 추상화된 공통 예외로 변환해주긴 하지만 근본적인 한계 때문에 완벽하다고 기대할 수는 없다. 따라서 사용에 주의를 기울여야 한다.

만약 DAO에서 사용하는 기술의 종류와 상관없이 동일한 예외를 얻고 싶다면 직접 예외를 정의해두고, 각 DAO의 메소드에서 좀 더 상세한 예외 전환을 해줄 필요가 있다.

>   스프링은 `SQLException`을 `DataAccessException`으로 전환하는 다양한 방법을 제공한다. `SQLException`을 코드에서 직접 전환하고 싶다면 `SQLExceptionTranslator` 인터페이스를 구현한 클래스 중에서 `SQLErrorCodeSQLExceptionTranslator`를 사용하면 된다.



