# 서비스 추상화

##  비즈니스 로직의 추상화

### 상수 필드는 enum을 사용하자

코드를 작성하다 보면 상수 필드를 선언하여 사용할 일이 생긴다. 보통의 경우 상수 필드를 정수형 타입으로 선언하여 사용하는 경우가 많은데, 숫자 타입은 선언된 상수 이외의 값이 들어가더라도 컴파일러가 체크해주지 못한다는 단점이 있다. 때문에 숫자 타입을 직접 사용하는 것보다는 자바 5 이상에서 제공하는 이넘(enum)을 이용하는 것이 편리하다. 

이넘 타입은 사용자가 선언한 값이 아니거나 다른 타입을 사용할 때 컴파일러가 에러를 잡아주어 자칫 잘못된 값이 들어가는 것을 방지해 줄 수 있는 장점이 있다.

### 문자열 상수는 항상 오타를 체크하자

문자열의 경우 다른 타입의 값보다 훨씬 잘못된 값이 들어갈 확률이 높다. 사용자가 직접 작성할 때 오타를 자주 내기 때문이다. 따라서 문자열을 다룰 때는 조금 더 주의해야 한다.

*   문자열을 사용하는 코드는 문자열이 문제가 없는 지 항상 테스트를 진행하여 검증을 해야한다.
*   문자열 자체를 상수화 시켜 상수 필드를 참조하여 사용하는 방법도 있다.

### 코드 개선
작성된 코드를 살펴볼 때는 다음과 같은 질문을 해볼 필요가 있다.

*   코드에 중복된 부분은 없는가?
*   코드가 무엇을 하는 것인지 이해하기 불편하지 않은가?
*   코드가 자신이 있어야 할 자리에 있는가?
*   앞으로 변경이 일어난다면 어떤 것이 있을 수 있고, 그 변화에 쉽게 대응할 수 있게 작성되어 있는가?

### 객체지향 관점을 항상 생각하자
각각의 오브젝트들은 자신이 맡은 역할에 충실하고 다른 오브젝트의 역할을 대신해서는 안된다. 이러한 기준으로 코드를 작성하다 보면 자연스레 객체지향적인 코드를 짤 수 있으며 변화에 유연하게 대처할 수 있다.

---

## 트랜잭션 서비스 추상화

>   트랜잭션이란
>
>   더 이상 나눌 수 없는 단위 작업을 말한다. 작업을 쪼개서 작은 단위로 만들 수 없다는 것은 트랜잭션의 핵심 속성인 원자성을 의미한다.

비즈니스 로직을 수행하는 도중 시스템에 문제가 생겨서 진행중이던 작업이 중단될 수 있다. 이 때 중단된 작업을 처리할 결정하고 테스트를 통해 확인해야만 한다.

하지만 시스템에 장애가 발생하는 환경을 만들기란 쉽지 않는데, 테스트는 항상 자동화된 테스트여야 하므로 사람이 테스트에 개입해서는 좋지않다. 때문에 강제로 예외가 발생하도록 만드는 테스트용 오브젝트가 필요하다.

### 테스트용 대역
시스템 장애 상황에서의 테스트를 위해 정상적인 기능을 수정하는 것은 위험하므로 좋은 생각이 아니다. 따라서 정상적인 코드는 그대로 두고 테스트를 위한 코드를 따로 작성해야 한다.

그렇다면 테스트용 코드를 만드는 좋은 방법은 무엇이 있는가? 가장 쉽게 생각할 수 있는 방법은 기존의 코드를 그대로 복사해서 코드를 일부 변경하는 것이다. 하지만 코드 중복도 발생하고 사용하기도 번거롭다. 간단히 테스트하려는 클래스를 상속하여 테스트에 필요한 기능을 추가하도록 일부 메소드를 오버라이딩하는 방법이 낫다.

### 트랜잭션 경계설정
DB는 그 자체로 완벽한 트랜잭션을 지원한다. SQL을 이용해 다중 로우의 수정이나 삭제를 위한 요청을 했을 때 일부 로우만 삭제되고 나머지는 안 된다거나, 일부 필드는 수정했는데 나머지 필드는 수정이 안 되고 실패로 끝나는 경우는 없다. 하나의 SQL 명령을 처리하는 경우는 DB가 트랜잭션을 보장해준다고 믿을 수 있다.

문제는 여러 개의 SQL이 사용되는 작업을 하나의 트랜잭션으로 취급해야 하는 경우도 있다. 이 때는 중간에 문제가 발생했을 때 이전에 성공한 작업들을 취소하는 **트랜잭션 롤백(transaction rollback)**과 반대로 성공적으로 작업이 마무리 되었을 때 성공여부를 DB에 알려주는 트랜잭션 **커밋(transaction commit)**을 이용한다.

JDBC의 트랜잭션의 경계설정 방법
*   모든 트랜잭션은 시작하는 지점과 끝나는 지점이 있다.
*   `Connection`을 가져와 사용하다가 닫는 사이에서 일어난다.
*   트랜잭션의 시작과 종료는 `Connection` 오브젝트를 통해 이루어진다.
*   정상적인 경우 `commit()`, 문제가 발생한 경우 `rollback()`을 사용한다.

**트랜잭션을 사용하기 위해서는 작업이 진행되는 동안 반드시 하나의 커넥션만 사용돼야 한다.**

### 비즈니스 로직 내의 트랜잭션 경계설정
비즈니스 로직과 데이터 접근 기술을 분리 시킨 경우(DAO, Service), 하나의 서비스가 여러번 Dao를 사용할 때 Dao에서는 매번 새로운 커넥션이 생성된다. 때문에 하나의 트랜잭션으로 묶는 것이 불가능하다.

=> 트랜잭션을 적용하려면 결국 트랜잭션의 경계설정 작업을 서비스 쪽으로 가져와야 한다. 

서비스단에서 만든 커넥션을 DAO까지 전달해 동일한 커넥션을 사용하도록 하면 트랜잭션으로 하나의 서비스를 묶을 수 있다. 하지만 이러한 방식은 여러 가지 새로운 문제가 발생한다.

1.  DB 커넥션을 비롯한 리소스의 깔끔한 처리를 가능하게 했던 `JDBCTemplate`을 더 이상 활용할 수 없다.
2.  DAO의 메소드와 비즈니스 로직을 담고 있는 서비스의 메소드에 `Connection` 파라미터가 추가돼야 한다.
3.  `Connection` 파라미터가 DAO 인터페이스 메소드에 추가되면 해당 DAO 더 이상 데이터 액세스 기술에 독립적일 수 없다.
4.  DAO 메소드에 `Connection` 파라미터를 받게 하면 테스트 코드에도 영향을 미친다.

### 트랜잭션 동기화
서비스 메소드가 트랜잭션 경계설정을 해야 한다는 사실은 피할 수 없다. 따라서 그 안에서 `Connection`을 생성하고 트랜잭션 시작과 종료를 관리하게 된다. 스프링은 이를 위해 독립적인 **트랜잭션 동기화(transaction synchronization)**를 제공한다.

>   트랜잭션 동기화란
>
>   서비스에서 트랜잭션을 시작하기 위해 만든 `Connection` 오브젝트를 특별한 저장소에 보관해두고, 이후에 호출되는 `DAO`의 메소드에서는 저장된 `Connection`을 가져다가 사용하게 하는 것이다. 정확히는 `DAO`가 사용하는 `JdbcTemplate`이 트랜잭션 동기화 방식을 이용하도록 하는 것이다. 트랜잭션이 모두 종료되면, 그때는 동기화를 마치면 된다.

#### 스프링에서의 트랜잭션 동기화 적용
*   TransactionSynchronizationManager를 이용

### 기술과 환경게 종속되는 트랜잭션 경계설정 코드
만약 하나의 서비스에 사용되는 DB가 여러개이면, 각 DB마다 사용되는 `Connection`도 다를 것이다. 이런 경우에는 트랜잭션을 적용시키는 것에 제한이 있다. 이를 해결하기 위해 하나 이상의 DB로 작업하는 경우 글로벌 트랜잭션을 사용해야 한다. 하나의 `Connection`에 종속되는 로컬 트랜잭션으로는 불가능하다.

자바는 `JDBC` 외에 이런 글로벌 트랜잭션을 지원하는 트랜잭션 매니저를 지원하기 위한 API인 **JTA(Java Transaction API)**를 제공하고 있다.

로컬 트랜잭션이 필요한 곳과 글로벌 트랜잭션이 필요한 곳 모두 충족할 수 없다.

### 스프링의 트랜잭션 서비스 추상화
스프링은 트랜잭션 기술의 공통점을 담은 트랜잭션 추상화 기술을 제공하고 있다. 이를 이용하면 애플리케이션에서 직접 각 기술의 트랜잭션 API를 이용하지 않고도, 일관된 방식으로 트랜잭션을 제어하는 트랜잭션 경계설정이 가능해진다.

---

##  서비스 추상화와 단일 책임 원칙

### 수직, 수평 계층구조와 의존관계

*   수평적인 분리

    같은 애플리케이션 로직을 담은 코드지만 내용에 따라 분리하는 것을 말한다. (로직적인 분리)
*   수직적인 분리

    서로 다른 계층의 특성을 갖는 코드를 분리하는 것을 말한다. (기술적인 분리)

---

## 테스트 대역

테스트 대상이 되는 오브젝트의 기능에만 충실하게 수행하면서 빠르게, 자주 테스트를 실행할 수 있도록 사용하는 오브젝트.

## 테스트 스텁

테스트 대상 오브젝트의 의존객체로 존재한다. 테스트 동안 코드가 정상적으로 수행될 수 있도록 돕는다.

## 목 오브젝트
테스트 -> 테스트 대상 오브젝트 -> 의존/협력 오브젝트(목 오브젝트)

테스트와 테스트 대상 오브젝트의 입출력만으로는 검증할 수 없는 오류들이 존재한다.
테스트 대상의 간접적인 출력 결과를 검증하고 오브젝트 사이에서 일어나는 일을 검증할 수 있도록 설계된 오브젝트를 목 오브젝트라고 한다.